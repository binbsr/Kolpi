@inject HttpClient Http

@using Kolpi.Shared.ViewModels
@using System.ComponentModel.DataAnnotations

<EditForm Model="@Model" OnValidSubmit="OnValidSubmit">
<DataAnnotationsValidator/>
        <MudCard>
            <MudCardContent>
                <MudTextField Label="Name" HelperText="Max. 8 characters"
                              @bind-Value="Model.Name" For="@(() => Model.Name)"/>
                <MudTextField Label="Details" Class="mt-3"
                              @bind-Value="Model.Details" For="@(() => Model.Details)"/>
                <MudAutocomplete T="string"
                             Label="Tag Category"
                             SearchFunc="Search"
                             ResetValueOnEmptyText=true
                             @bind-Value="Model.TagTypeName"/>
            </MudCardContent>
            <MudCardActions>
                <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto">
                    Save Tag
                </MudButton>
            </MudCardActions>
        </MudCard>
</EditForm>


@code {

    [Parameter]
    public TagViewModel Model { get; set; } = new TagViewModel();

    bool success;
    public string TagType { get; set; } = default!;
    public TagTypeViewModel[] TagTypes { get; set; } = default!;

    private async Task<IEnumerable<string>> Search(string value)
    {
        TagTypes = await Http.GetFromJsonAsync<TagTypeViewModel[]>("api/tagtypes") ?? Array.Empty<TagTypeViewModel>();

        if (string.IsNullOrEmpty(value))
            return TagTypes.Select(x => x.Name);
        return TagTypes.Select(x => x.Name)
                       .Where(y => y.Contains(value, StringComparison.InvariantCultureIgnoreCase));
    }

    private void OnValidSubmit(EditContext context)
    {
        success = true;
        StateHasChanged();
    }
}


@*

@code {
    
    List<TagTypeViewModel> tagCategories = new List<TagTypeViewModel>();
    private readonly Func<string, SelectOption<string, string>, bool> FilterOptionValue = FilterOption;
    int selectedTagTypeId = default;
    bool isSaving = false;

    private async Task OnFinish(EditContext editContext)
    {
        isSaving = true;
        await InvokeAsync(StateHasChanged);

        Task<HttpResponseMessage> saveTask;

        if (TagViewModel.Id == default)
        {
            // Adding new
            TagViewModel.TagTypeId = selectedTagTypeId;
            saveTask = http.PostAsJsonAsync("api/tags", TagViewModel);
        }
        else
        {
            // Modify existing
            TagViewModel.TagTypeId = selectedTagTypeId;
            saveTask = http.PutAsJsonAsync($"api/tags/{TagViewModel.Id}", TagViewModel);
        }

        await saveTask.ContinueWith(st =>
        {
            isSaving = false;
            InvokeAsync(StateHasChanged);

            var result = st.Result;

            if (result.IsSuccessStatusCode)
            {
                message.Success("Tag saved successfully.");
            }
            else
            {
                message.Error($"Error occured while saving tag. Problem: {result.ReasonPhrase}");
            }
        });
    }

    private static bool FilterOption(string value, SelectOption<string, string> option)
    {
        var optionContent = option.Value.ToUpper();
        return optionContent.Contains(value, StringComparison.OrdinalIgnoreCase);
    }

    private void OnChange(string value)
    {
        selectedTagTypeId = int.Parse(value);
    }

    protected override async Task OnInitializedAsync()
    {
        tagCategories = await http.GetFromJsonAsync<List<TagTypeViewModel>>("api/tagtypes");
    }
}

*@
